マルチスレッドと姿勢ダブルバッファの仕様
EditMot 1.2.0.30時点での仕様のメモ

2023_11_11 おちゃっこ@おちゃっこLAB


マルチスレッドはCThreadingBaseクラスから各用途のクラスを派生させてコーディングした
基本クラスでは
スレッド開始終了同期に使用するオブジェクトを管理
派生クラスでは
スレッド内で各用途に特化した関数を呼び出している

用途を限定することにより
オブジェクト書き込み中に読み込むことが無い前提を作り
クリティカルセクション使用を出来る限り少なくしている

例えば
オイラー角計算のスレッドにおいては
前フレームのオイラー角が必要になる
よって計算時のフレーム順について連続していなければならない
全ボーンの姿勢は既にモーションとして揃っている
マルチスレッドのコンテクストとしてはボーンを選んだ
つまり全ボーンを４つのスレッドに分割して
それぞれのスレッドからフレーム順を守って計算を行った
モーションデータはボーンクラスに存在している
この計算においては同じモーションデータに対して書き込みと読み込みは同時には起こらない
クリティカルセクションは最低限で済む


別の例として　IKについてメモ
IK処理は　マウスドラッグ中はアプライフレームだけをシングルスレッドで計算する
ドラッグ操作直後に　マルチスレッドで選択フレームの計算を行う
このようにすることでアプリのレスポンスは改善する
ドラッグ後のマルチスレッド計算について
計算開始前に揃っているデータとしてはアプライフレームにおける全ボーンの姿勢
IK計算においてはボーン階層順に計算する必要がある
よってマルチスレッドのコンテクストとしてはフレームを選んだ
つまり選択範囲のフレームを４スレッドに分割して
それぞれのスレッドからフレーム順を守って計算を行った
モーションデータはボーンの中にフレーム単位で格納されている
この計算においては同じモーションデータに対して書き込みと読み込みは同時には起こらない
クリティカルセクションは最低限で済む



IKマルチスレッド終了後には　オイラー角更新のためにオイラー角マルチスレッドを呼び出した



ダブルバッファについてメモ
３Dシーンの描画においてマルチスレッド化だけではそれほど効果が現れないことも多い
効果を得るには　描画と姿勢計算を同時に行う必要がある
そのためには　姿勢に関して計算中のデータと表示用のデータを用意する
つまりダブルバッファ化する
描画シェーダーに渡す姿勢データだけダブルバッファ化すればよい
全てのモーションをダブルバッファにするのではない
姿勢データを長さ２の配列にして０または１のスロット番号でアクセスする
書き込み中データに読み込まないために
描画と姿勢計算を同時に行った後にまとめて１回分の計算終了を待つ

物理の計算についても同様

ダブルバッファのためのマルチスレッドに関しては
書き込み中に読み込まないためにモデルクラスをコンテクストとした



こちらの環境で使ってみたところ
マルチスレッドとダブルバッファにより
１モデルだけの描画速度はそれほどには変わらなかったが
複数モデル(例えば６モデル)を物理シミュした場合に
１モデルの描画速度とほぼ同等の速度で描画することが出来た
参考までに
4K画面で１モデル物理シミュ123fps, 背景の街と６モデル物理シミュ110fps　というテスト結果だった





